

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>meshmagick.mesh &mdash; Meshmagick User&#39;s Guide 3.2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Meshmagick User's Guide
          

          
          </a>

          
            
            
              <div class="version">
                3.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../install/install.html">Installation Instructions</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../command_line/index.html">Meshmagick’s Command Line Interface</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/index.html">Meshmagick Package’s modules</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Meshmagick User's Guide</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>meshmagick.mesh</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for meshmagick.mesh</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1">#  -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module concerns mesh data structures.</span>

<span class="sd">TODO: mettre des examples d&#39;utilisation</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">vtk</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">count</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>
<span class="kn">import</span> <span class="nn">sys</span>  <span class="c1"># TODO: Retirer</span>

<span class="kn">from</span> <span class="nn">.tools</span> <span class="kn">import</span> <span class="n">merge_duplicate_rows</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">MMviewer</span>
<span class="kn">from</span> <span class="nn">.inertia</span> <span class="kn">import</span> <span class="n">RigidBodyInertia</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Francois Rongere&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s2">&quot;Copyright 2014-2015, Ecole Centrale de Nantes / D-ICE ENGINEERING&quot;</span>
<span class="n">__credits__</span> <span class="o">=</span> <span class="s2">&quot;Francois Rongere&quot;</span>
<span class="n">__licence__</span> <span class="o">=</span> <span class="s2">&quot;GPLv3&quot;</span>
<span class="n">__maintainer__</span> <span class="o">=</span> <span class="s2">&quot;Francois Rongere&quot;</span>
<span class="n">__email__</span> <span class="o">=</span> <span class="s2">&quot;Francois.Rongere@dice-engineering.com&quot;</span>
<span class="n">__status__</span> <span class="o">=</span> <span class="s2">&quot;Development&quot;</span>

<span class="c1"># TODO: Use traitlets to manage updates into the Mesh class</span>
<span class="c1"># TODO: les points doivent etre des objects nodes...</span>
<span class="c1"># TODO: On doit pouvoir specifier des objets frame</span>
<span class="c1"># TODO: voir si on ne peut pas mettre ces fonctions dans un module dedie --&gt; module rotation !!!</span>

<span class="kn">from</span> <span class="nn">.rotations</span> <span class="kn">import</span> <span class="n">cardan_to_rotmat</span><span class="p">,</span> <span class="n">rotmat_to_cardan</span>

<span class="k">def</span> <span class="nf">_rodrigues</span><span class="p">(</span><span class="n">thetax</span><span class="p">,</span> <span class="n">thetay</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the rotation matrix corresponding to angles thetax and thetay using the Olinde-Rodrigues formula</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    thetax : float</span>
<span class="sd">        Angle around Ox axe (rad)</span>
<span class="sd">    thetay</span>
<span class="sd">        Angle around Oy axe (rad)</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rot : ndarray</span>
<span class="sd">        Rotation matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">theta</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">thetax</span><span class="o">*</span><span class="n">thetax</span> <span class="o">+</span> <span class="n">thetay</span><span class="o">*</span><span class="n">thetay</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">theta</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">ny</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="n">ctheta</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="n">stheta</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">thetax</span><span class="o">/</span><span class="n">theta</span><span class="p">,</span> <span class="n">thetay</span><span class="o">/</span><span class="n">theta</span>
        <span class="n">ctheta</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">stheta</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">nxny</span> <span class="o">=</span> <span class="n">nx</span><span class="o">*</span><span class="n">ny</span>

    <span class="c1"># Olinde Rodrigues formulae</span>
    <span class="c1"># FIXME: S&#39;assurer qu&#39;on a effectivement pas de Ctheta devant le I3 !! et repercuter sur l&#39;hydrostatique</span>
    <span class="n">rot</span> <span class="o">=</span> <span class="n">ctheta</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> \
        <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">ctheta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">nx</span><span class="o">*</span><span class="n">nx</span><span class="p">,</span> <span class="n">nxny</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
                                 <span class="p">[</span><span class="n">nxny</span><span class="p">,</span> <span class="n">ny</span><span class="o">*</span><span class="n">ny</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
                                 <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span> \
        <span class="o">+</span> <span class="n">stheta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span>  <span class="n">ny</span><span class="p">],</span>
                             <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="n">nx</span><span class="p">],</span>
                             <span class="p">[</span><span class="o">-</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">rot</span>


<span class="k">def</span> <span class="nf">_cardan</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the rotation matrix corresponding to angles phi (roll) and theta (pitch) using Cardan angles convention</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    phi : float</span>
<span class="sd">        Roll angle (rad)</span>
<span class="sd">    theta : float</span>
<span class="sd">        Pitch angel (rad)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    R : ndarray</span>
<span class="sd">        Rotation matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Rotation matrix</span>
    <span class="n">cphi</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    <span class="n">sphi</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    <span class="n">ctheta</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">stheta</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

    <span class="n">rot_e0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">rot_e0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">ctheta</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="n">stheta</span><span class="p">]</span>
    <span class="n">rot_e0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">sphi</span><span class="o">*</span><span class="n">stheta</span><span class="p">,</span> <span class="n">cphi</span><span class="p">,</span> <span class="n">sphi</span><span class="o">*</span><span class="n">ctheta</span><span class="p">]</span>
    <span class="n">rot_e0</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">cphi</span><span class="o">*</span><span class="n">stheta</span><span class="p">,</span> <span class="o">-</span><span class="n">sphi</span><span class="p">,</span> <span class="n">cphi</span><span class="o">*</span><span class="n">ctheta</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">rot_e0</span>


<span class="k">def</span> <span class="nf">_get_rotation_matrix</span><span class="p">(</span><span class="n">theta_x</span><span class="p">,</span> <span class="n">theta_y</span><span class="p">,</span> <span class="n">atype</span><span class="o">=</span><span class="s1">&#39;fixed&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes rotation matrix using different angle conventions</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    theta_x : float</span>
<span class="sd">        Angle around x (rad)</span>
<span class="sd">    theta_y : float</span>
<span class="sd">        Angle around y (rad)</span>
<span class="sd">    atype : {&#39;fixed&#39;, &#39;cardan&#39;}, optional</span>
<span class="sd">        Angle convention to use. Default to &#39;fixed&#39; (fixed axes)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        Rotation matrix</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">atype</span> <span class="o">==</span> <span class="s1">&#39;fixed&#39;</span><span class="p">:</span>
        <span class="n">rot_matrix</span> <span class="o">=</span> <span class="n">_rodrigues</span><span class="p">(</span><span class="n">theta_x</span><span class="p">,</span> <span class="n">theta_y</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">atype</span> <span class="o">==</span> <span class="s1">&#39;cardan&#39;</span><span class="p">:</span>
        <span class="n">rot_matrix</span> <span class="o">=</span> <span class="n">_cardan</span><span class="p">(</span><span class="n">theta_x</span><span class="p">,</span> <span class="n">theta_y</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Unknown angle convention: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">atype</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rot_matrix</span>


<span class="k">def</span> <span class="nf">_get_axis_angle_from_rotation_matrix</span><span class="p">(</span><span class="n">rot_matrix</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the angle and unit rotation axis from a rotation matrix&quot;&quot;&quot;</span>
    <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Fonction _get_axis_angle_from_rotation_matrix a verifier !!!&#39;</span><span class="p">)</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">rot_matrix</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">rot_matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">rot_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                                                      <span class="n">rot_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">rot_matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                                      <span class="n">rot_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">rot_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">theta</span><span class="p">,</span> <span class="n">direction</span>


<span class="c1"># Classes</span>
<span class="c1"># TODO: placer cette classe dans un module a part (genre geometry) --&gt; utilise dans meshmagick aussi...</span>
<div class="viewcode-block" id="Plane"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Plane">[docs]</a><span class="k">class</span> <span class="nc">Plane</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class to handle plane geometry.</span>

<span class="sd">    A plane is represented by the equation :math:`\\vec{n}.\\vec{x} = c` where :math:`\\vec{n}` is the plane&#39;s normal,</span>
<span class="sd">    :math:`\\vec{x}` a point in the space and :math:`c` a scalar parameter being the signed distance between the</span>
<span class="sd">    reference frame origin and the its otrhogonal projection on the plane.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    normal : array_like</span>
<span class="sd">        3 component vector of the plane normal</span>
<span class="sd">    scalar : float</span>
<span class="sd">        The scalar parameter of the plane</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normal</span><span class="o">=</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">),</span> <span class="n">scalar</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="n">normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_normal</span> <span class="o">=</span> <span class="n">normal</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scalar</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">scalar</span><span class="p">)</span>

        <span class="c1"># Storing rotation matrix (redundant !) to speedup computations</span>
        <span class="c1"># Shall be _update in methods !!! --&gt; using decorator ?</span>
        <span class="n">theta_x</span><span class="p">,</span> <span class="n">theta_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_normal_orientation_wrt_z</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rot</span> <span class="o">=</span> <span class="n">_get_rotation_matrix</span><span class="p">(</span><span class="n">theta_x</span><span class="p">,</span> <span class="n">theta_y</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">str_repr</span> <span class="o">=</span> <span class="s2">&quot;Plane{normal=[</span><span class="si">%f</span><span class="s2">, </span><span class="si">%f</span><span class="s2">, </span><span class="si">%f</span><span class="s2">], scalar=</span><span class="si">%f</span><span class="s2">}&quot;</span> <span class="o">%</span> \
                   <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_normal</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normal</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normal</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scalar</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">str_repr</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">normal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the plane&#39;s normal&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normal</span>

    <span class="nd">@normal</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">normal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the plane&#39;s normal&quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_normal</span> <span class="o">=</span> <span class="n">value</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">c</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the plane&#39;s scalar parameter&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scalar</span>

    <span class="nd">@c</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">c</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the scalar parameter of the plane equation&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scalar</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<div class="viewcode-block" id="Plane.rotate_normal"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Plane.rotate_normal">[docs]</a>    <span class="k">def</span> <span class="nf">rotate_normal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta_x</span><span class="p">,</span> <span class="n">theta_y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotates the current plane normal by fixed angles theta_x and theta_y.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta_x : float</span>
<span class="sd">            Angle of rotation around Ox (rad)</span>
<span class="sd">        theta_y : float</span>
<span class="sd">            Angle of rotation around Oy (rad)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rot_matrix</span> <span class="o">=</span> <span class="n">_get_rotation_matrix</span><span class="p">(</span><span class="n">theta_x</span><span class="p">,</span> <span class="n">theta_y</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rot_matrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span>

        <span class="c1"># updating self._rot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rot_matrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rot</span><span class="p">)</span></div>

<div class="viewcode-block" id="Plane.set_normal_from_angles"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Plane.set_normal_from_angles">[docs]</a>    <span class="k">def</span> <span class="nf">set_normal_from_angles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta_x</span><span class="p">,</span> <span class="n">theta_y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the normal orientation given angles theta_x and theta_y.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta_x : float</span>
<span class="sd">            Angle around Ox (rad)</span>
<span class="sd">        theta_y : float</span>
<span class="sd">            Angle around Oy (rad)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">theta</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">theta_x</span> <span class="o">*</span> <span class="n">theta_x</span> <span class="o">+</span> <span class="n">theta_y</span> <span class="o">*</span> <span class="n">theta_y</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">theta</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]</span>

            <span class="c1"># updating self._rot</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stheta_theta</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">/</span> <span class="n">theta</span>
            <span class="n">ctheta</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">stheta_theta</span> <span class="o">*</span> <span class="n">theta_y</span><span class="p">,</span>
                                       <span class="o">-</span><span class="n">stheta_theta</span> <span class="o">*</span> <span class="n">theta_x</span><span class="p">,</span>
                                       <span class="n">ctheta</span><span class="p">])</span>
            <span class="c1"># Updating self._rot</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rot</span> <span class="o">=</span> <span class="n">_get_rotation_matrix</span><span class="p">(</span><span class="n">theta_x</span><span class="p">,</span> <span class="n">theta_y</span><span class="p">)</span></div>

<div class="viewcode-block" id="Plane.get_normal_orientation_wrt_z"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Plane.get_normal_orientation_wrt_z">[docs]</a>    <span class="k">def</span> <span class="nf">get_normal_orientation_wrt_z</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the angles theta_x and theta_y giving the orientation of the plane normal&quot;&quot;&quot;</span>

        <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span>
        <span class="n">stheta</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">nx</span><span class="o">*</span><span class="n">nx</span> <span class="o">+</span> <span class="n">ny</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span>
        <span class="n">ctheta</span> <span class="o">=</span> <span class="n">nz</span>
        <span class="n">theta_x</span> <span class="o">=</span> <span class="n">theta_y</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">if</span> <span class="n">stheta</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nz</span> <span class="o">==</span> <span class="mf">1.</span><span class="p">:</span>
                <span class="n">theta_x</span> <span class="o">=</span> <span class="n">theta_y</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="k">elif</span> <span class="n">nz</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.</span><span class="p">:</span>
                <span class="n">theta_x</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
                <span class="n">theta_y</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">stheta</span><span class="p">,</span> <span class="n">ctheta</span><span class="p">)</span>
            <span class="n">theta_stheta</span> <span class="o">=</span> <span class="n">theta</span> <span class="o">/</span> <span class="n">stheta</span>

            <span class="n">theta_x</span> <span class="o">=</span> <span class="o">-</span><span class="n">theta_stheta</span> <span class="o">*</span> <span class="n">ny</span>
            <span class="n">theta_y</span> <span class="o">=</span> <span class="n">theta_stheta</span> <span class="o">*</span> <span class="n">nx</span>

        <span class="k">return</span> <span class="n">theta_x</span><span class="p">,</span> <span class="n">theta_y</span></div>

<div class="viewcode-block" id="Plane.set_plane_parameters"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Plane.set_plane_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">set_plane_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scalar</span><span class="p">,</span> <span class="n">theta_x</span><span class="p">,</span> <span class="n">theta_y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the plane parameters (normal and scalar parameter) given scalar and angles.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scalar : float</span>
<span class="sd">            Plane scalar parameter (m)</span>
<span class="sd">        theta_x : float</span>
<span class="sd">            Normal angle around Ox (rad)</span>
<span class="sd">        theta_y : float</span>
<span class="sd">            Normal angle around Oy (rad)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rotate_normal</span><span class="p">(</span><span class="n">theta_x</span><span class="p">,</span> <span class="n">theta_y</span><span class="p">)</span>
        <span class="n">ctheta</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">theta_x</span> <span class="o">*</span> <span class="n">theta_x</span> <span class="o">+</span> <span class="n">theta_y</span> <span class="o">*</span> <span class="n">theta_y</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scalar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scalar</span> <span class="o">*</span> <span class="n">ctheta</span> <span class="o">+</span> <span class="n">scalar</span></div>

<div class="viewcode-block" id="Plane.get_point_dist_wrt_plane"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Plane.get_point_dist_wrt_plane">[docs]</a>    <span class="k">def</span> <span class="nf">get_point_dist_wrt_plane</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the orthogonal distance of points with respect to the plane</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        points : ndarray</span>
<span class="sd">            Array of points coordinates</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dist : ndarray</span>
<span class="sd">            Array of distances of points with respect to the plane</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normal</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scalar</span></div>

<div class="viewcode-block" id="Plane.flip_normal"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Plane.flip_normal">[docs]</a>    <span class="k">def</span> <span class="nf">flip_normal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Flips the Normal of the plane</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normal</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">theta_x</span><span class="p">,</span> <span class="n">theta_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_normal_orientation_wrt_z</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rot</span> <span class="o">=</span> <span class="n">_get_rotation_matrix</span><span class="p">(</span><span class="n">theta_x</span><span class="p">,</span> <span class="n">theta_y</span><span class="p">)</span></div>

<div class="viewcode-block" id="Plane.coord_in_plane"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Plane.coord_in_plane">[docs]</a>    <span class="k">def</span> <span class="nf">coord_in_plane</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the coordinates of points in the frame of the plane</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        points : ndarray</span>
<span class="sd">            Array of points coordinates</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output : ndarray</span>
<span class="sd">            Array of points coordinates in the frame of the plane</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO: verifier effectivement que si on prend des points se trouvant dans le plan, leurs coordonnees dans le</span>
        <span class="c1">#  plan n&#39;ont pas de composante z</span>
        <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_scalar</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rot</span><span class="p">,</span> <span class="n">points</span><span class="o">.</span><span class="n">T</span><span class="p">))</span></div>

<div class="viewcode-block" id="Plane.get_edge_intersection"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Plane.get_edge_intersection">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the coordinates of the intersection point between the plane and the edge P0P1.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        p0 : ndarray</span>
<span class="sd">            Coordinates of point p0</span>
<span class="sd">        p1 : ndarray</span>
<span class="sd">            Coordinates of point P1</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        I : ndarray</span>
<span class="sd">            Coordinates of intersection point</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>

        <span class="n">p0n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span>
        <span class="n">p1n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">p0n</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scalar</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">p0n</span> <span class="o">-</span> <span class="n">p1n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mf">0.</span> <span class="ow">or</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="mf">1.</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Intersection is outside the edge&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">p0</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">p1</span></div>

<div class="viewcode-block" id="Plane.orthogonal_projection_on_plane"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Plane.orthogonal_projection_on_plane">[docs]</a>    <span class="k">def</span> <span class="nf">orthogonal_projection_on_plane</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the coordinates of the orthogonal projection of points</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        points : ndarray</span>
<span class="sd">            Coordinates of the points to be projected</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        projected_points : ndarray</span>
<span class="sd">            Coordinates of the projection points</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: passer en vectoriel</span>
        <span class="n">projected_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">point</span><span class="p">,</span> <span class="n">projected_point</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">projected_points</span><span class="p">):</span>
            <span class="n">projected_point</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">point</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_point_dist_wrt_plane</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span>

        <span class="k">return</span> <span class="n">projected_points</span></div>

<div class="viewcode-block" id="Plane.get_origin"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Plane.get_origin">[docs]</a>    <span class="k">def</span> <span class="nf">get_origin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the coordinates of the plane&#39;s origin&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span></div></div>


<span class="k">class</span> <span class="nc">_3DPointsArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">points</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="k">lambda</span> <span class="bp">cls</span><span class="p">:</span> <span class="bp">cls</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="k">lambda</span> <span class="bp">cls</span><span class="p">:</span> <span class="bp">cls</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="k">lambda</span> <span class="bp">cls</span><span class="p">:</span> <span class="bp">cls</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">obj</span>


<div class="viewcode-block" id="Mesh"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh">[docs]</a><span class="k">class</span> <span class="nc">Mesh</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class to handle unstructured meshes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vertices : array_like</span>
<span class="sd">        (nv x 3) Array of mesh vertices coordinates. Each line of the array represents one vertex coordinates</span>
<span class="sd">    faces : array_like</span>
<span class="sd">        Arrays of mesh connectivities for faces. Each line of the array represents indices of vertices that form the</span>
<span class="sd">        face, expressed in counterclockwise order to ensure outward normals description.</span>
<span class="sd">    name : str, optional</span>
<span class="sd">        The mesh&#39;s name. If None, mesh is given an automatic name based on its internal ID.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_ids</span> <span class="o">=</span> <span class="n">count</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">faces</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ids</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="s1">&#39;mesh_</span><span class="si">%u</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="Mesh.__str__"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.__str__">[docs]</a>    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String representation of the mesh</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_aligned_bbox</span>

        <span class="n">str_repr</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        --------------------------------------------</span>
<span class="s2">        </span><span class="se">\t</span><span class="s2">MESH NAME : </span><span class="si">%s</span><span class="s2"></span>
<span class="s2">        --------------------------------------------</span>

<span class="s2">        Number of vertices: </span><span class="si">%u</span><span class="s2"></span>
<span class="s2">        Number of faces:    </span><span class="si">%u</span><span class="s2"></span>

<span class="s2">        Number of triangles:   </span><span class="si">%u</span><span class="s2"></span>
<span class="s2">        Number of quadrangles: </span><span class="si">%u</span><span class="s2"></span>

<span class="s2">        xmin = </span><span class="si">%f</span><span class="se">\t</span><span class="s2">xmax = </span><span class="si">%f</span><span class="s2"></span>
<span class="s2">        ymin = </span><span class="si">%f</span><span class="se">\t</span><span class="s2">ymax = </span><span class="si">%f</span><span class="s2"></span>
<span class="s2">        zmin = </span><span class="si">%f</span><span class="se">\t</span><span class="s2">zmax = </span><span class="si">%f</span><span class="s2"></span>


<span class="s2">        &quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">nb_vertices</span><span class="p">,</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">nb_faces</span><span class="p">,</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">nb_triangles</span><span class="p">,</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">nb_quadrangles</span><span class="p">,</span>
               <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span>
               <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span>
               <span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span>
               <span class="p">)</span>
        <span class="k">return</span> <span class="n">str_repr</span></div>

<div class="viewcode-block" id="Mesh.print_quality"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.print_quality">[docs]</a>    <span class="k">def</span> <span class="nf">print_quality</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns data on the mesh quality</span>

<span class="sd">        It uses VTK and is reproduced from</span>
<span class="sd">        http://vtk.org/gitweb?p=VTK.git;a=blob;f=Filters/Verdict/Testing/Python/MeshQuality.py</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This function is reproduced from</span>
        <span class="c1"># http://vtk.org/gitweb?p=VTK.git;a=blob;f=Filters/Verdict/Testing/Python/MeshQuality.py</span>
        <span class="n">polydata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vtk_polydata</span><span class="p">()</span>
        <span class="n">quality</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkMeshQuality</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">vtk</span><span class="o">.</span><span class="n">VTK_MAJOR_VERSION</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">quality</span><span class="o">.</span><span class="n">SetInput</span><span class="p">(</span><span class="n">polydata</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">quality</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="n">polydata</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">DumpQualityStats</span><span class="p">(</span><span class="n">iq</span><span class="p">,</span> <span class="n">arrayname</span><span class="p">):</span>
            <span class="n">an</span> <span class="o">=</span> <span class="n">iq</span><span class="o">.</span><span class="n">GetOutput</span><span class="p">()</span><span class="o">.</span><span class="n">GetFieldData</span><span class="p">()</span><span class="o">.</span><span class="n">GetArray</span><span class="p">(</span><span class="n">arrayname</span><span class="p">)</span>
            <span class="n">cardinality</span> <span class="o">=</span> <span class="n">an</span><span class="o">.</span><span class="n">GetComponent</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
            <span class="nb">range</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="nb">range</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">an</span><span class="o">.</span><span class="n">GetComponent</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="nb">range</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">an</span><span class="o">.</span><span class="n">GetComponent</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">average</span> <span class="o">=</span> <span class="n">an</span><span class="o">.</span><span class="n">GetComponent</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">stdDev</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">an</span><span class="o">.</span><span class="n">GetComponent</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>
            <span class="n">outStr</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s%g%s%g</span><span class="se">\n</span><span class="si">%s%g%s%g</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="s1">&#39;    range: &#39;</span><span class="p">,</span> <span class="nb">range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;  -  &#39;</span><span class="p">,</span> <span class="nb">range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="s1">&#39;    average: &#39;</span><span class="p">,</span> <span class="n">average</span><span class="p">,</span> <span class="s1">&#39;  , standard deviation: &#39;</span><span class="p">,</span> <span class="n">stdDev</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">outStr</span>

        <span class="c1"># Here we define the various mesh types and labels for output.</span>
        <span class="n">meshTypes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="s1">&#39;Triangle&#39;</span><span class="p">,</span> <span class="s1">&#39;Triangle&#39;</span><span class="p">,</span>
             <span class="p">[[</span><span class="s1">&#39;QualityMeasureToArea&#39;</span><span class="p">,</span> <span class="s1">&#39; Area Ratio:&#39;</span><span class="p">],</span>
              <span class="p">[</span><span class="s1">&#39;QualityMeasureToEdgeRatio&#39;</span><span class="p">,</span> <span class="s1">&#39; Edge Ratio:&#39;</span><span class="p">],</span>
              <span class="p">[</span><span class="s1">&#39;QualityMeasureToAspectRatio&#39;</span><span class="p">,</span> <span class="s1">&#39; Aspect Ratio:&#39;</span><span class="p">],</span>
              <span class="p">[</span><span class="s1">&#39;QualityMeasureToRadiusRatio&#39;</span><span class="p">,</span> <span class="s1">&#39; Radius Ratio:&#39;</span><span class="p">],</span>
              <span class="p">[</span><span class="s1">&#39;QualityMeasureToAspectFrobenius&#39;</span><span class="p">,</span> <span class="s1">&#39; Frobenius Norm:&#39;</span><span class="p">],</span>
              <span class="p">[</span><span class="s1">&#39;QualityMeasureToMinAngle&#39;</span><span class="p">,</span> <span class="s1">&#39; Minimal Angle:&#39;</span><span class="p">]</span>
              <span class="p">]</span>
             <span class="p">],</span>

            <span class="p">[</span><span class="s1">&#39;Quad&#39;</span><span class="p">,</span> <span class="s1">&#39;Quadrilateral&#39;</span><span class="p">,</span>
             <span class="p">[[</span><span class="s1">&#39;QualityMeasureToArea&#39;</span><span class="p">,</span> <span class="s1">&#39; Area Ratio:&#39;</span><span class="p">],</span>
              <span class="p">[</span><span class="s1">&#39;QualityMeasureToEdgeRatio&#39;</span><span class="p">,</span> <span class="s1">&#39; Edge Ratio:&#39;</span><span class="p">],</span>
              <span class="p">[</span><span class="s1">&#39;QualityMeasureToAspectRatio&#39;</span><span class="p">,</span> <span class="s1">&#39; Aspect Ratio:&#39;</span><span class="p">],</span>
              <span class="p">[</span><span class="s1">&#39;QualityMeasureToRadiusRatio&#39;</span><span class="p">,</span> <span class="s1">&#39; Radius Ratio:&#39;</span><span class="p">],</span>
              <span class="p">[</span><span class="s1">&#39;QualityMeasureToMedAspectFrobenius&#39;</span><span class="p">,</span>
               <span class="s1">&#39; Average Frobenius Norm:&#39;</span><span class="p">],</span>
              <span class="p">[</span><span class="s1">&#39;QualityMeasureToMaxAspectFrobenius&#39;</span><span class="p">,</span>
               <span class="s1">&#39; Maximal Frobenius Norm:&#39;</span><span class="p">],</span>
              <span class="p">[</span><span class="s1">&#39;QualityMeasureToMinAngle&#39;</span><span class="p">,</span> <span class="s1">&#39; Minimal Angle:&#39;</span><span class="p">]</span>
              <span class="p">]</span>
             <span class="p">]</span>
        <span class="p">]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">if</span> <span class="n">polydata</span><span class="o">.</span><span class="n">GetNumberOfCells</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">meshType</span> <span class="ow">in</span> <span class="n">meshTypes</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="si">%s%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">meshType</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39; quality of the mesh &#39;</span><span class="p">)</span>
                <span class="n">quality</span><span class="o">.</span><span class="n">Update</span><span class="p">()</span>
                <span class="n">an</span> <span class="o">=</span> <span class="n">quality</span><span class="o">.</span><span class="n">GetOutput</span><span class="p">()</span><span class="o">.</span><span class="n">GetFieldData</span><span class="p">()</span><span class="o">.</span><span class="n">GetArray</span><span class="p">(</span><span class="s1">&#39;Mesh &#39;</span> <span class="o">+</span> <span class="n">meshType</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39; Quality&#39;</span><span class="p">)</span>
                <span class="n">cardinality</span> <span class="o">=</span> <span class="n">an</span><span class="o">.</span><span class="n">GetComponent</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

                <span class="n">res</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">res</span><span class="p">,</span> <span class="s1">&#39;(</span><span class="si">%u</span><span class="s1"> elements):</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">cardinality</span><span class="p">))</span>

                <span class="c1"># res += &#39;(&#39;+str(cardinality) +meshType[1]+&#39;):\n&#39;</span>

                <span class="k">for</span> <span class="n">measure</span> <span class="ow">in</span> <span class="n">meshType</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                    <span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;quality.Set&#39;</span> <span class="o">+</span> <span class="n">meshType</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">measure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;()&#39;</span><span class="p">)</span>
                    <span class="n">quality</span><span class="o">.</span><span class="n">Update</span><span class="p">()</span>
                    <span class="n">res</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                        <span class="n">measure</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">DumpQualityStats</span><span class="p">(</span><span class="n">quality</span><span class="p">,</span> <span class="s1">&#39;Mesh &#39;</span> <span class="o">+</span> <span class="n">meshType</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39; Quality&#39;</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="n">info</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\n\n</span><span class="s2">Definition of the different quality measures is given</span>
<span class="s2">        in the verdict library manual :</span>
<span class="s2">        http://www.vtk.org/Wiki/images/6/6b/VerdictManual-revA.pdf</span><span class="se">\n</span><span class="s2">&quot;&quot;&quot;</span>

        <span class="n">res</span> <span class="o">+=</span> <span class="n">info</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="k">return</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">verbose</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get verbosity</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span>

    <span class="nd">@verbose</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">verbose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span>

<div class="viewcode-block" id="Mesh.verbose_on"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.verbose_on">[docs]</a>    <span class="k">def</span> <span class="nf">verbose_on</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the verbosity level of the instance to on.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="Mesh.verbose_off"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.verbose_off">[docs]</a>    <span class="k">def</span> <span class="nf">verbose_off</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the verbosity level of the instance to off.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the id of the mesh</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            hash id of the instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the name of the mesh&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@name</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nb_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the number of vertices in the mesh</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nb_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the number of faces in the mesh</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the vertices array coordinate of the mesh</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">faces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the faces connectivity array of the mesh</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span>

    <span class="nd">@vertices</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># self._vertices.setflags(write=False)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">return</span>

    <span class="nd">@faces</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">faces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># self._faces.setflags(write=False)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_faces_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates the faces properties of the mesh&quot;&quot;&quot;</span>

        <span class="c1"># faces_areas, faces_normals, faces_centers = mm.get_all_faces_properties(self._vertices, self._faces)</span>
        <span class="n">nf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_faces</span>

        <span class="c1"># triangle_mask = _faces[:, 0] == _faces[:, -1]</span>
        <span class="c1"># nb_triangles = np.sum(triangle_mask)</span>
        <span class="c1"># quads_mask = np.invert(triangle_mask)</span>
        <span class="c1"># nb_quads = nf - nb_triangles</span>

        <span class="n">faces_areas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nf</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">faces_normals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nf</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">faces_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nf</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># Collectively dealing with triangles</span>
        <span class="c1"># triangles = _faces[triangle_mask]</span>
        <span class="n">triangles_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">triangles_ids</span>
        <span class="n">triangles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="p">[</span><span class="n">triangles_id</span><span class="p">]</span>

        <span class="n">triangles_normals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[</span><span class="n">triangles</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[</span><span class="n">triangles</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]],</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[</span><span class="n">triangles</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[</span><span class="n">triangles</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]])</span>
        <span class="n">triangles_areas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">triangles_normals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">faces_normals</span><span class="p">[</span><span class="n">triangles_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">triangles_normals</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(([</span><span class="n">triangles_areas</span><span class="p">,</span> <span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">faces_areas</span><span class="p">[</span><span class="n">triangles_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">triangles_areas</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="n">faces_centers</span><span class="p">[</span><span class="n">triangles_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[</span><span class="n">triangles</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.</span>

        <span class="c1"># Collectively dealing with quads</span>
        <span class="n">quads_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quadrangles_ids</span>
        <span class="n">quads</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="p">[</span><span class="n">quads_id</span><span class="p">]</span>
        <span class="c1"># quads = _faces[quads_mask]</span>

        <span class="n">quads_normals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[</span><span class="n">quads</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[</span><span class="n">quads</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]],</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[</span><span class="n">quads</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[</span><span class="n">quads</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]])</span>
        <span class="n">faces_normals</span><span class="p">[</span><span class="n">quads_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">quads_normals</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(([</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">quads_normals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

        <span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[</span><span class="n">quads</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[</span><span class="n">quads</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]],</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[</span><span class="n">quads</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[</span><span class="n">quads</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[</span><span class="n">quads</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[</span><span class="n">quads</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]],</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[</span><span class="n">quads</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[</span><span class="n">quads</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span>
        <span class="n">faces_areas</span><span class="p">[</span><span class="n">quads_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">a1</span> <span class="o">+</span> <span class="n">a2</span>

        <span class="n">c1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[</span><span class="n">quads</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[</span><span class="n">quads</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[</span><span class="n">quads</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]])</span> <span class="o">/</span> <span class="mf">3.</span>

        <span class="n">faces_centers</span><span class="p">[</span><span class="n">quads_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(([</span><span class="n">a1</span><span class="p">,</span> <span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">c1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(([</span><span class="n">a2</span><span class="p">,</span> <span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">c2</span><span class="p">)</span>
        <span class="n">faces_centers</span><span class="p">[</span><span class="n">quads_id</span><span class="p">]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(([</span><span class="n">faces_areas</span><span class="p">[</span><span class="n">quads_id</span><span class="p">],</span> <span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

        <span class="n">faces_properties</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;faces_areas&#39;</span><span class="p">:</span> <span class="n">faces_areas</span><span class="p">,</span>
                            <span class="s1">&#39;faces_normals&#39;</span><span class="p">:</span> <span class="n">faces_normals</span><span class="p">,</span>
                            <span class="s1">&#39;faces_centers&#39;</span><span class="p">:</span> <span class="n">faces_centers</span><span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">faces_properties</span><span class="p">)</span>

        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_has_faces_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;faces_areas&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span>

    <span class="k">def</span> <span class="nf">_remove_faces_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_faces_properties</span><span class="p">():</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;faces_areas&#39;</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;faces_centers&#39;</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;faces_normals&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_surface_integrals</span><span class="p">():</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;surface_integrals&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_triangles_quadrangles</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_remove_triangles_quadrangles</span><span class="p">()</span>
        <span class="k">return</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">faces_areas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the array of faces areas of the mesh</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;faces_areas&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_faces_properties</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;faces_areas&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">faces_centers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the array of faces centers of the mesh</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;faces_centers&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_faces_properties</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;faces_centers&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">faces_normals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the array of faces normals of the mesh</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;faces_normals&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_faces_properties</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;faces_normals&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_triangles_quadrangles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">triangle_mask</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">quadrangles_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">triangle_mask</span><span class="p">)</span>
        <span class="n">triangles_quadrangles</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;triangles_ids&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">triangle_mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                                 <span class="s1">&#39;quadrangles_ids&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">quadrangles_mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">triangles_quadrangles</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_has_triangles_quadrangles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;triangles_ids&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span>

    <span class="k">def</span> <span class="nf">_remove_triangles_quadrangles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;triangles_ids&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;triangles_ids&#39;</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;quadrangles_ids&#39;</span><span class="p">]</span>
        <span class="k">return</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">triangles_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the array of ids of triangle shaped faces</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;triangles_ids&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_triangles_quadrangles</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;triangles_ids&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nb_triangles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the number of triangles in the mesh</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;triangles_ids&#39;</span><span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_triangles_quadrangles</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;triangles_ids&#39;</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">quadrangles_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the array of ids of qudrangle shaped faces</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;triangles_ids&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_triangles_quadrangles</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;quadrangles_ids&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nb_quadrangles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the number of quadrangles in the mesh</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;triangles_ids&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_triangles_quadrangles</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;quadrangles_ids&#39;</span><span class="p">])</span>

<div class="viewcode-block" id="Mesh.is_triangle"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.is_triangle">[docs]</a>    <span class="k">def</span> <span class="nf">is_triangle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">face_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns if a face is a triangle</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        face_id : int</span>
<span class="sd">            Face id</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if the face with id face_id is a triangle</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">face_id</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_faces</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="p">[</span><span class="n">face_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="p">[</span><span class="n">face_id</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="Mesh.get_face"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.get_face">[docs]</a>    <span class="k">def</span> <span class="nf">get_face</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">face_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the face described by its vertices connectivity</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        face_id : int</span>
<span class="sd">            Face id</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">            If the face is a triangle, the array has 3 components, else it has 4 (quadrangle)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_triangle</span><span class="p">(</span><span class="n">face_id</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="p">[</span><span class="n">face_id</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="p">[</span><span class="n">face_id</span><span class="p">]</span></div>

<div class="viewcode-block" id="Mesh.extract_faces"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.extract_faces">[docs]</a>    <span class="k">def</span> <span class="nf">extract_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_faces_to_extract</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts a new mesh from a selection of faces ids</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        id_faces_to_extract : ndarray</span>
<span class="sd">            Indices of faces that have to be extracted</span>
<span class="sd">        return_index: bool</span>
<span class="sd">            Flag to output old indices</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Mesh</span>
<span class="sd">            A new Mesh instance composed of the extracted faces</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_vertices</span>

        <span class="c1"># Determination of the vertices to keep</span>
        <span class="n">vertices_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nv</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">vertices_mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="p">[</span><span class="n">id_faces_to_extract</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">id_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nv</span><span class="p">)[</span><span class="n">vertices_mask</span><span class="p">]</span>

        <span class="c1"># Building up the vertex array</span>
        <span class="n">v_extracted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[</span><span class="n">id_v</span><span class="p">]</span>
        <span class="n">new_id__v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nv</span><span class="p">)</span>
        <span class="n">new_id__v</span><span class="p">[</span><span class="n">id_v</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">id_v</span><span class="p">))</span>

        <span class="n">faces_extracted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="p">[</span><span class="n">id_faces_to_extract</span><span class="p">]</span>
        <span class="n">faces_extracted</span> <span class="o">=</span> <span class="n">new_id__v</span><span class="p">[</span><span class="n">faces_extracted</span><span class="o">.</span><span class="n">flatten</span><span class="p">()]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">id_faces_to_extract</span><span class="p">),</span> <span class="mi">4</span><span class="p">))</span>

        <span class="n">extracted_mesh</span> <span class="o">=</span> <span class="n">Mesh</span><span class="p">(</span><span class="n">v_extracted</span><span class="p">,</span> <span class="n">faces_extracted</span><span class="p">)</span>
        <span class="n">extracted_mesh</span><span class="o">.</span><span class="n">_verbose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span>

        <span class="n">extracted_mesh</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;mesh_extracted_from_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

        <span class="k">if</span> <span class="n">return_index</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">extracted_mesh</span><span class="p">,</span> <span class="n">id_v</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">extracted_mesh</span></div>

    <span class="k">def</span> <span class="nf">_vtk_polydata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO: placer cette methode dans MMviewer !!</span>
        <span class="c1"># Create a vtkPoints object and store the points in it</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkPoints</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">:</span>
            <span class="n">points</span><span class="o">.</span><span class="n">InsertNextPoint</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>

        <span class="c1"># Create a vtkCellArray to store faces</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkCellArray</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">face_ids</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">face_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">face_ids</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># Triangle</span>
                <span class="n">curface</span> <span class="o">=</span> <span class="n">face_ids</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
                <span class="n">vtk_face</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkTriangle</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Quadrangle</span>
                <span class="n">curface</span> <span class="o">=</span> <span class="n">face_ids</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
                <span class="n">vtk_face</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkQuad</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="nb">id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">curface</span><span class="p">):</span>
                <span class="n">vtk_face</span><span class="o">.</span><span class="n">GetPointIds</span><span class="p">()</span><span class="o">.</span><span class="n">SetId</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">id</span><span class="p">)</span>

            <span class="n">faces</span><span class="o">.</span><span class="n">InsertNextCell</span><span class="p">(</span><span class="n">vtk_face</span><span class="p">)</span>

        <span class="n">vtk_polydata</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkPolyData</span><span class="p">()</span>
        <span class="n">vtk_polydata</span><span class="o">.</span><span class="n">SetPoints</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="n">vtk_polydata</span><span class="o">.</span><span class="n">SetPolys</span><span class="p">(</span><span class="n">faces</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">vtk_polydata</span>

<div class="viewcode-block" id="Mesh.show"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.show">[docs]</a>    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shows the mesh in the meshmagick viewer&quot;&quot;&quot;</span>

        <span class="n">vtk_polydata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vtk_polydata</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">viewer</span> <span class="o">=</span> <span class="n">MMviewer</span><span class="o">.</span><span class="n">MMViewer</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">viewer</span><span class="o">.</span><span class="n">add_polydata</span><span class="p">(</span><span class="n">vtk_polydata</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">viewer</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">viewer</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_connectivity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates the connectivities of the mesh.</span>

<span class="sd">        It concerns further connectivity than simple faces/vertices connectivities. It computes the vertices / vertices, vertices / faces and faces / faces connectivities.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>

<span class="sd">        Note that if the mesh is not conformal, the algorithm may not perform correctly</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_vertices</span>
        <span class="n">nf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_faces</span>

        <span class="n">mesh_closed</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Building connectivities</span>

        <span class="c1"># Establishing v_v and v_f connectivities</span>
        <span class="n">v_v</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">i</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nv</span><span class="p">)])</span>
        <span class="n">v_f</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">i</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nv</span><span class="p">)])</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">iface</span><span class="p">,</span> <span class="n">face</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">face</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">face</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">face_w</span> <span class="o">=</span> <span class="n">face</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">face_w</span> <span class="o">=</span> <span class="n">face</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">iV</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">face_w</span><span class="p">):</span>
                <span class="n">v_f</span><span class="p">[</span><span class="n">iV</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">iface</span><span class="p">)</span>
                <span class="n">v_v</span><span class="p">[</span><span class="n">face_w</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">iV</span><span class="p">)</span>
                <span class="n">v_v</span><span class="p">[</span><span class="n">iV</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">face_w</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Connectivity f_f</span>
        <span class="n">boundary_edges</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="n">f_f</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">i</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nf</span><span class="p">)])</span>
        <span class="k">for</span> <span class="n">ivertex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nv</span><span class="p">):</span>
            <span class="n">set1</span> <span class="o">=</span> <span class="n">v_f</span><span class="p">[</span><span class="n">ivertex</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">iadj_v</span> <span class="ow">in</span> <span class="n">v_v</span><span class="p">[</span><span class="n">ivertex</span><span class="p">]:</span>
                <span class="n">set2</span> <span class="o">=</span> <span class="n">v_f</span><span class="p">[</span><span class="n">iadj_v</span><span class="p">]</span>
                <span class="n">intersection</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">set1</span> <span class="o">&amp;</span> <span class="n">set2</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersection</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">f_f</span><span class="p">[</span><span class="n">intersection</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">intersection</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">f_f</span><span class="p">[</span><span class="n">intersection</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">intersection</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersection</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">boundary_face</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="p">[</span><span class="n">intersection</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

                    <span class="k">if</span> <span class="n">boundary_face</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">boundary_face</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">boundary_face</span> <span class="o">=</span> <span class="n">boundary_face</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
                    <span class="n">ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">boundary_face</span> <span class="o">==</span> <span class="n">ivertex</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">boundary_face</span> <span class="o">==</span> <span class="n">iadj_v</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">ids</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">i_v_orig</span><span class="p">,</span> <span class="n">i_v_target</span> <span class="o">=</span> <span class="n">boundary_face</span><span class="p">[</span><span class="n">ids</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">i_v_target</span><span class="p">,</span> <span class="n">i_v_orig</span> <span class="o">=</span> <span class="n">boundary_face</span><span class="p">[</span><span class="n">ids</span><span class="p">]</span>

                    <span class="n">boundary_edges</span><span class="p">[</span><span class="n">i_v_orig</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_v_target</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Unexpected error while computing mesh connectivities&#39;</span><span class="p">)</span>

        <span class="c1"># Computing boundaries</span>
        <span class="n">boundaries</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="c1"># TODO: calculer des boundaries fermees et ouvertes (closed_boundaries et open_boundaries) et mettre dans dict</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">boundary</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                <span class="n">i_v0_init</span><span class="p">,</span> <span class="n">i_v1</span> <span class="o">=</span> <span class="n">boundary_edges</span><span class="o">.</span><span class="n">popitem</span><span class="p">()</span>
                <span class="n">boundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i_v0_init</span><span class="p">)</span>
                <span class="n">boundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i_v1</span><span class="p">)</span>
                <span class="n">i_v0</span> <span class="o">=</span> <span class="n">i_v1</span>

                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">i_v1</span> <span class="o">=</span> <span class="n">boundary_edges</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i_v0</span><span class="p">)</span>
                        <span class="n">boundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i_v1</span><span class="p">)</span>
                        <span class="n">i_v0</span> <span class="o">=</span> <span class="n">i_v1</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">boundary</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="n">mesh_closed</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">boundaries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">boundary</span><span class="p">)</span>
                        <span class="k">break</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">mesh_closed</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;FOUND OPEN BOUNDARY!!!&#39;</span><span class="p">)</span>

        <span class="n">connectivity</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;v_v&#39;</span><span class="p">:</span> <span class="n">v_v</span><span class="p">,</span>
                        <span class="s1">&#39;v_f&#39;</span><span class="p">:</span> <span class="n">v_f</span><span class="p">,</span>
                        <span class="s1">&#39;f_f&#39;</span><span class="p">:</span> <span class="n">f_f</span><span class="p">,</span>
                        <span class="s1">&#39;boundaries&#39;</span><span class="p">:</span> <span class="n">boundaries</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">connectivity</span><span class="p">)</span>

        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_has_connectivity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;v_v&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span>

    <span class="k">def</span> <span class="nf">_remove_connectivity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;v_v&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;v_v&#39;</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;v_f&#39;</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;f_f&#39;</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;boundaries&#39;</span><span class="p">]</span>
        <span class="k">return</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the vertex / vertex connectivity dictionary.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;v_v&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_connectivity</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;v_v&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the vertex / faces connectivity dictionary.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;v_f&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_connectivity</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;v_f&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ff</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the face / faces connectivity dictionary</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;f_f&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_connectivity</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;f_f&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the list of boundaries of the mesh.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            list that stores lists of boundary connected vertices</span>


<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        The computation of boundaries should be in the future computed with help of VTK</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;boundaries&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_connectivity</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;boundaries&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nb_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the number of boundaries in the mesh</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            Number of boundaries</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;boundaries&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_connectivity</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;boundaries&#39;</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axis_aligned_bbox</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the axis aligned bounding box of the mesh.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            (xmin, xmax, ymin, ymax, zmin, zmax)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_vertices</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="o">.</span><span class="n">T</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span>
                    <span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span>
                    <span class="n">z</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">z</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">squared_axis_aligned_bbox</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a squared axis aligned bounding box of the mesh.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            (xmin, xmax, ymin, ymax, zmin, zmax)</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This method differs from `axis_aligned_bbox()` by the fact that the bounding box that is returned is squared but have the same center as the AABB</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_aligned_bbox</span>
        <span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">z0</span><span class="p">)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xmin</span><span class="o">+</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="o">+</span><span class="n">ymax</span><span class="p">,</span> <span class="n">zmin</span><span class="o">+</span><span class="n">zmax</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xmax</span><span class="o">-</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymax</span><span class="o">-</span><span class="n">ymin</span><span class="p">,</span> <span class="n">zmax</span><span class="o">-</span><span class="n">zmin</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">x0</span><span class="o">-</span><span class="n">d</span><span class="p">,</span> <span class="n">x0</span><span class="o">+</span><span class="n">d</span><span class="p">,</span> <span class="n">y0</span><span class="o">-</span><span class="n">d</span><span class="p">,</span> <span class="n">y0</span><span class="o">+</span><span class="n">d</span><span class="p">,</span> <span class="n">z0</span><span class="o">-</span><span class="n">d</span><span class="p">,</span> <span class="n">z0</span><span class="o">+</span><span class="n">d</span>

<div class="viewcode-block" id="Mesh.is_mesh_closed"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.is_mesh_closed">[docs]</a>    <span class="k">def</span> <span class="nf">is_mesh_closed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns if the mesh is a closed manifold.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if the mesh is closed (i.e. it has no boundaries)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;boundaries&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_connectivity</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;boundaries&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="Mesh.is_mesh_conformal"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.is_mesh_conformal">[docs]</a>    <span class="k">def</span> <span class="nf">is_mesh_conformal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns if the mesh is conformal.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if the mesh is conformal.</span>

<span class="sd">        Warning</span>
<span class="sd">        -------</span>
<span class="sd">        This method is experimental. Use at your own risk !</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;This method is not stable yet !! Use with caution&#39;</span><span class="p">)</span>
        <span class="c1"># FIXME: experimental method</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-7</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_connectivity</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_connectivity</span><span class="p">()</span>

        <span class="n">boundaries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;boundaries&#39;</span><span class="p">]</span>
        <span class="n">conformal</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">for</span> <span class="n">boundary</span> <span class="ow">in</span> <span class="n">boundaries</span><span class="p">:</span>
            <span class="n">boundary_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[</span><span class="n">boundary</span><span class="p">]</span>
            <span class="c1"># Si les trois projections (Oxy, Oxz, Oyz) de boundary sont des courbes dans ces plans, alors la courbe</span>
            <span class="c1"># est colapsee</span>
            <span class="c1"># Projecting on Oxy</span>
            <span class="n">plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="n">normal</span><span class="o">=</span><span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span>
            <span class="n">proj0</span> <span class="o">=</span> <span class="n">plane</span><span class="o">.</span><span class="n">orthogonal_projection_on_plane</span><span class="p">(</span><span class="n">boundary_vertices</span><span class="p">)</span>
            <span class="c1"># Projecting on Oyz</span>
            <span class="n">plane</span><span class="o">.</span><span class="n">normal</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]</span>
            <span class="n">proj1</span> <span class="o">=</span> <span class="n">plane</span><span class="o">.</span><span class="n">orthogonal_projection_on_plane</span><span class="p">(</span><span class="n">boundary_vertices</span><span class="p">)</span>
            <span class="c1"># Projecting on Oxz</span>
            <span class="n">plane</span><span class="o">.</span><span class="n">normal</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]</span>
            <span class="n">proj2</span> <span class="o">=</span> <span class="n">plane</span><span class="o">.</span><span class="n">orthogonal_projection_on_plane</span><span class="p">(</span><span class="n">boundary_vertices</span><span class="p">)</span>

            <span class="c1"># Compputing areas of curves</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">proj0</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">proj0</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">a0</span> <span class="o">=</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="n">y</span> <span class="o">=</span> <span class="n">proj1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">proj1</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">a1</span> <span class="o">=</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">z</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="n">x</span> <span class="o">=</span> <span class="n">proj2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">proj2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">a2</span> <span class="o">=</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">z</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">a0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">and</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">and</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                <span class="n">conformal</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">return</span> <span class="n">conformal</span></div>

<div class="viewcode-block" id="Mesh.rotate_x"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.rotate_x">[docs]</a>    <span class="k">def</span> <span class="nf">rotate_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">thetax</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rotates the mesh around Ox axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        thetax : float</span>
<span class="sd">            Angle (rad)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">            The (3x3) rotation matrix that has been applied to rotate the mesh</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">([</span><span class="n">thetax</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])</span></div>

<div class="viewcode-block" id="Mesh.rotate_y"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.rotate_y">[docs]</a>    <span class="k">def</span> <span class="nf">rotate_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">thetay</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rotates the mesh around Oy axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        thetay : float</span>
<span class="sd">            Angle (rad)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">            The (3x3) rotation matrix that has been applied to rotate the mesh</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="n">thetay</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])</span></div>

<div class="viewcode-block" id="Mesh.rotate_z"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.rotate_z">[docs]</a>    <span class="k">def</span> <span class="nf">rotate_z</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">thetaz</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rotates the mesh around Oz axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        thetaz : float</span>
<span class="sd">            Angle (rad)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">            The (3x3) rotation matrix that has been applied to rotate the mesh</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">thetaz</span><span class="p">])</span></div>

<div class="viewcode-block" id="Mesh.rotate"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angles</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rotates the mesh in 3D giving the 3 rotation angles that are defined around fixed axes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        angles : array_like</span>
<span class="sd">            The 3 angles of the 3D rotation (rad)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">            The (3x3) rotation matrix that has been applied to rotate the mesh</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">psi</span> <span class="o">=</span> <span class="n">angles</span>

        <span class="n">rotmat</span> <span class="o">=</span> <span class="n">cardan_to_rotmat</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">psi</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rotate_matrix</span><span class="p">(</span><span class="n">rotmat</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">rotmat</span></div>

<div class="viewcode-block" id="Mesh.rotate_matrix"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.rotate_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">rotate_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rotmat</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_surface_integrals</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_remove_surface_integrals</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rotmat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_faces_properties</span><span class="p">():</span>
            <span class="c1"># Rotating normals and centers too</span>
            <span class="n">normals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;faces_normals&#39;</span><span class="p">]</span>
            <span class="n">centers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;faces_centers&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;faces_normals&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rotmat</span><span class="p">,</span> <span class="n">normals</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;faces_centers&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rotmat</span><span class="p">,</span> <span class="n">centers</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_surface_integrals</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_remove_surface_integrals</span><span class="p">()</span></div>




<div class="viewcode-block" id="Mesh.translate_x"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.translate_x">[docs]</a>    <span class="k">def</span> <span class="nf">translate_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Translates the mesh along the Ox axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tx : float</span>
<span class="sd">            Distance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span>
        <span class="n">vertices</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span> <span class="o">=</span> <span class="n">vertices</span>

        <span class="c1"># Updating properties if any</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_faces_properties</span><span class="p">():</span>
            <span class="n">centers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;faces_centers&#39;</span><span class="p">]</span>
            <span class="n">centers</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tx</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;faces_centers&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">centers</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_surface_integrals</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_remove_surface_integrals</span><span class="p">()</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="Mesh.translate_y"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.translate_y">[docs]</a>    <span class="k">def</span> <span class="nf">translate_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ty</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Translates the mesh along the Oy axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ty : float</span>
<span class="sd">            Distance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">vertices</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ty</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span> <span class="o">=</span> <span class="n">vertices</span>

        <span class="c1"># Updating properties if any</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_faces_properties</span><span class="p">():</span>
            <span class="n">centers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;faces_centers&#39;</span><span class="p">]</span>
            <span class="n">centers</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ty</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;faces_centers&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">centers</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_surface_integrals</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_remove_surface_integrals</span><span class="p">()</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="Mesh.translate_z"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.translate_z">[docs]</a>    <span class="k">def</span> <span class="nf">translate_z</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tz</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Translates the mesh along the Oz axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tz : float</span>
<span class="sd">            Distance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">vertices</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tz</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span> <span class="o">=</span> <span class="n">vertices</span>

        <span class="c1"># Updating properties if any</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_faces_properties</span><span class="p">():</span>
            <span class="n">centers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;faces_centers&#39;</span><span class="p">]</span>
            <span class="n">centers</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tz</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;faces_centers&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">centers</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_surface_integrals</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_remove_surface_integrals</span><span class="p">()</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="Mesh.translate"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.translate">[docs]</a>    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Translates the mesh in 3D giving the 3 distances along coordinate axes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        t : array_like</span>
<span class="sd">            translation vector</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">tz</span> <span class="o">=</span> <span class="n">t</span>
        <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># FIXME: why doing a copy ???</span>
        <span class="n">V</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tx</span>
        <span class="n">V</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ty</span>
        <span class="n">V</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tz</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span> <span class="o">=</span> <span class="n">V</span>

        <span class="c1"># Updating properties if any</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_faces_properties</span><span class="p">():</span>
            <span class="n">centers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;faces_centers&#39;</span><span class="p">]</span>
            <span class="n">centers</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tx</span>
            <span class="n">centers</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ty</span>
            <span class="n">centers</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tz</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;faces_centers&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">centers</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_surface_integrals</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_remove_surface_integrals</span><span class="p">()</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="Mesh.scale"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.scale">[docs]</a>    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Scales the mesh.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        alpha : float</span>
<span class="sd">            A positive scaling factor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">alpha</span>

        <span class="c1"># TODO: voir pourquoi il est fait une copie ici...</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">vertices</span> <span class="o">*=</span> <span class="nb">float</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span> <span class="o">=</span> <span class="n">vertices</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_faces_properties</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_remove_faces_properties</span><span class="p">()</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="Mesh.scalex"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.scalex">[docs]</a>    <span class="k">def</span> <span class="nf">scalex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Scales the mesh along the x axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        alpha : float</span>
<span class="sd">            A positive scaling factor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">alpha</span>

        <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">vertices</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="nb">float</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span> <span class="o">=</span> <span class="n">vertices</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_faces_properties</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_remove_faces_properties</span><span class="p">()</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="Mesh.scaley"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.scaley">[docs]</a>    <span class="k">def</span> <span class="nf">scaley</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Scales the mesh along the y axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        alpha : float</span>
<span class="sd">            A positive scaling factor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">alpha</span>

        <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">vertices</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="nb">float</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span> <span class="o">=</span> <span class="n">vertices</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_faces_properties</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_remove_faces_properties</span><span class="p">()</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="Mesh.scalez"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.scalez">[docs]</a>    <span class="k">def</span> <span class="nf">scalez</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Scales the mesh along the z axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        alpha : float</span>
<span class="sd">            A positive scaling factor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">alpha</span>

        <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">vertices</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="nb">float</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span> <span class="o">=</span> <span class="n">vertices</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_faces_properties</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_remove_faces_properties</span><span class="p">()</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="Mesh.flip_normals"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.flip_normals">[docs]</a>    <span class="k">def</span> <span class="nf">flip_normals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Flips every normals of the mesh.&quot;&quot;&quot;</span>

        <span class="n">faces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">faces</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_faces_properties</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;faces_normals&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_surface_integrals</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_remove_surface_integrals</span><span class="p">()</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="Mesh.__add__"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.__add__">[docs]</a>    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh_to_add</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds two meshes</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mesh_to_add : Mesh</span>
<span class="sd">            The other mesh instance to add to the current instance</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Mesh</span>
<span class="sd">            The composite mesh</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This method should not be called as is but it overides the + binary operator for convenience.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mesh_to_add</span><span class="p">,</span> <span class="n">Mesh</span><span class="p">)</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">,</span> <span class="n">mesh_to_add</span><span class="o">.</span><span class="n">_vertices</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="p">,</span> <span class="n">mesh_to_add</span><span class="o">.</span><span class="n">_faces</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_vertices</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">new_mesh</span> <span class="o">=</span> <span class="n">Mesh</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">mesh_to_add</span><span class="o">.</span><span class="n">name</span><span class="p">]))</span>
        <span class="n">new_mesh</span><span class="o">.</span><span class="n">merge_duplicates</span><span class="p">()</span>
        <span class="n">new_mesh</span><span class="o">.</span><span class="n">_verbose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span> <span class="ow">or</span> <span class="n">mesh_to_add</span><span class="o">.</span><span class="n">_verbose</span>

        <span class="k">return</span> <span class="n">new_mesh</span></div>

<div class="viewcode-block" id="Mesh.copy"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a copy of the current mesh instance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Mesh</span>
<span class="sd">            mesh instance copy</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Mesh.merge_duplicates"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.merge_duplicates">[docs]</a>    <span class="k">def</span> <span class="nf">merge_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merges the duplicate vertices of the mesh.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atol : float, optional</span>
<span class="sd">            Absolute tolerance. default is 1e-8</span>
<span class="sd">        return_index : bool, optional</span>
<span class="sd">            Flag to return</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_id : ndarray, optional</span>
<span class="sd">            Array of indices that merges the vertices. Returned if return_index = True</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        meshmagick.tools.merge_duplicate_rows</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">uniq</span><span class="p">,</span> <span class="n">new_id</span> <span class="o">=</span> <span class="n">merge_duplicate_rows</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">nv_init</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_vertices</span>

        <span class="c1"># Updating mesh data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span> <span class="o">=</span> <span class="n">uniq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span> <span class="o">=</span> <span class="n">new_id</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="p">]</span> <span class="c1"># Faces vertices ids are updated here</span>

        <span class="n">nv_final</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_vertices</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">((</span><span class="s2">&quot;* Merging duplicate vertices that lie in an absolute proximity of </span><span class="si">%.1E</span><span class="s2">...&quot;</span> <span class="o">%</span> <span class="n">atol</span><span class="p">))</span>
            <span class="n">delta_n</span> <span class="o">=</span> <span class="n">nv_init</span> <span class="o">-</span> <span class="n">nv_final</span>
            <span class="k">if</span> <span class="n">delta_n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">--&gt; No duplicate vertices have been found&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">((</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">--&gt; Initial number of vertices : </span><span class="si">%u</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">nv_init</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">((</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">--&gt; Final number of vertices   : </span><span class="si">%u</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">nv_final</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">((</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">--&gt; </span><span class="si">%u</span><span class="s2"> vertices have been merged</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">delta_n</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_connectivity</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_remove_connectivity</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">return_index</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">new_id</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span></div>

<div class="viewcode-block" id="Mesh.heal_normals"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.heal_normals">[docs]</a>    <span class="k">def</span> <span class="nf">heal_normals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Heals the mesh&#39;s normals orientations so that they have a consistent orientation and try to make them outward.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: return the different groups of a mesh in case it is made of several unrelated groups</span>

        <span class="n">nv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_vertices</span>
        <span class="n">nf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_faces</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span>

        <span class="c1"># Building connectivities</span>
        <span class="n">v_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vv</span>
        <span class="n">v_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vf</span>
        <span class="n">f_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ff</span>
        <span class="n">boundaries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundaries</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">boundaries</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mesh_closed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mesh_closed</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Flooding the mesh to find inconsistent normals</span>
        <span class="n">type_cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nf</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">type_cell</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="n">type_cell</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">triangles_ids</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>

        <span class="n">f_vis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nf</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">f_vis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">nb_reversed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">f_vis</span><span class="p">)):</span>
                    <span class="n">iface</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">f_vis</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iface</span><span class="p">)</span>
                    <span class="n">f_vis</span><span class="p">[</span><span class="n">iface</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>

            <span class="n">iface</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">face</span> <span class="o">=</span> <span class="n">faces</span><span class="p">[</span><span class="n">iface</span><span class="p">]</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">face</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">iadj_f</span> <span class="ow">in</span> <span class="n">f_f</span><span class="p">[</span><span class="n">iface</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">f_vis</span><span class="p">[</span><span class="n">iadj_f</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="n">f_vis</span><span class="p">[</span><span class="n">iadj_f</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># Removing the other pointer</span>
                <span class="n">f_f</span><span class="p">[</span><span class="n">iadj_f</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">iface</span><span class="p">)</span>  <span class="c1"># So as it won&#39;t go from iadj_f to iface in the future</span>

                <span class="c1"># Shared vertices</span>
                <span class="n">adjface</span> <span class="o">=</span> <span class="n">faces</span><span class="p">[</span><span class="n">iadj_f</span><span class="p">]</span>
                <span class="n">s2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">adjface</span><span class="p">)</span>
                <span class="c1"># try:</span>
                <span class="n">common_vertices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">s1</span> <span class="o">&amp;</span> <span class="n">s2</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_vertices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">i_v1</span><span class="p">,</span> <span class="n">i_v2</span> <span class="o">=</span> <span class="n">common_vertices</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">((</span><span class="s1">&#39;WARNING: faces </span><span class="si">%u</span><span class="s1"> and </span><span class="si">%u</span><span class="s1"> have more than 2 vertices in common !&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">iface</span><span class="p">,</span> <span class="n">iadj_f</span><span class="p">)))</span>
                    <span class="k">continue</span>

                <span class="c1"># Checking normal consistency</span>
                <span class="n">face_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">face</span><span class="p">[:</span><span class="n">type_cell</span><span class="p">[</span><span class="n">iface</span><span class="p">]],</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">face</span> <span class="o">==</span> <span class="n">i_v1</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">adj_face_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">adjface</span><span class="p">[:</span><span class="n">type_cell</span><span class="p">[</span><span class="n">iadj_f</span><span class="p">]],</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">adjface</span> <span class="o">==</span> <span class="n">i_v1</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">face_ref</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">i_v2</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

                <span class="k">if</span> <span class="n">adj_face_ref</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">i_v2</span><span class="p">:</span>
                    <span class="c1"># Reversing normal</span>
                    <span class="n">nb_reversed</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">faces</span><span class="p">[</span><span class="n">iadj_f</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">faces</span><span class="p">[</span><span class="n">iadj_f</span><span class="p">])</span>

                <span class="c1"># Appending to the stack</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iadj_f</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;* Healing normals to make them consistent and if possible outward&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nb_reversed</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">((</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">--&gt; </span><span class="si">%u</span><span class="s1"> faces have been reversed to make normals consistent across the mesh&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nb_reversed</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">--&gt; Normals orientations are consistent&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span> <span class="o">=</span> <span class="n">faces</span>

        <span class="c1"># Checking if the normals are outward</span>
        <span class="k">if</span> <span class="n">mesh_closed</span><span class="p">:</span>
            <span class="n">zmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>

            <span class="n">areas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces_areas</span>
            <span class="n">normals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces_normals</span>
            <span class="n">centers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces_centers</span>
            <span class="c1"># areas, normals, centers = get_all_faces_properties(vertices, faces)</span>

            <span class="n">hs</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">centers</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">zmax</span><span class="p">)</span> <span class="o">*</span> <span class="n">areas</span><span class="p">,</span> <span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">normals</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-9</span>
            <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">hs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">tol</span> <span class="ow">or</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">hs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">--&gt; WARNING: the mesh does not seem watertight althought marked as closed...&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">hs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">flipped</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">flip_normals</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">flipped</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span> <span class="ow">and</span> <span class="n">flipped</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">--&gt; Every normals have been reversed to be outward&#39;</span><span class="p">)</span>


        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">--&gt; Mesh is not closed, meshmagick cannot test if the normals are outward&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_faces_properties</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_remove_faces_properties</span><span class="p">()</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="Mesh.remove_unused_vertices"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.remove_unused_vertices">[docs]</a>    <span class="k">def</span> <span class="nf">remove_unused_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes unused vertices in the mesh.</span>

<span class="sd">        Those are vertices that are not used by any face connectivity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: implementer return_index !!</span>
        <span class="n">nv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_vertices</span>
        <span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span>

        <span class="n">used_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nv</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">used_v</span><span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">faces</span><span class="p">)),</span> <span class="p">[])]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">nb_used_v</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">used_v</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nb_used_v</span> <span class="o">&lt;</span> <span class="n">nv</span><span class="p">:</span>
            <span class="n">new_id__v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nv</span><span class="p">)</span>
            <span class="n">new_id__v</span><span class="p">[</span><span class="n">used_v</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nb_used_v</span><span class="p">)</span>
            <span class="n">faces</span> <span class="o">=</span> <span class="n">new_id__v</span><span class="p">[</span><span class="n">faces</span><span class="p">]</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">used_v</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;* Removing unused vertices in the mesh:&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nb_used_v</span> <span class="o">&lt;</span> <span class="n">nv</span><span class="p">:</span>
                <span class="n">unused_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">used_v</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">vlist_str</span> <span class="o">=</span> <span class="s1">&#39;[&#39;</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">iV</span><span class="p">)</span> <span class="k">for</span> <span class="n">iV</span> <span class="ow">in</span> <span class="n">unused_v</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span>
                <span class="nb">print</span><span class="p">((</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">--&gt; </span><span class="si">%u</span><span class="s2"> unused vertices have been removed&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nv</span> <span class="o">-</span> <span class="n">nb_used_v</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">--&gt; No unused vertices&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_connectivity</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_remove_connectivity</span><span class="p">()</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="Mesh.heal_triangles"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.heal_triangles">[docs]</a>    <span class="k">def</span> <span class="nf">heal_triangles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Makes the triangle connectivity consistent.</span>

<span class="sd">        A general face is stored internally as a 4 integer array. It allows to describe indices of a quadrangle&#39;s vertices. For triangles, the first index should be equal to the last. This method ensures that this rule is applied everywhere and correct bad triangles description.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_faces_properties</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_remove_faces_properties</span><span class="p">()</span>

        <span class="n">faces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span>

        <span class="n">quads</span> <span class="o">=</span> <span class="n">faces</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">faces</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">nquads_init</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">quads</span><span class="p">)</span>

        <span class="n">faces</span><span class="p">[</span><span class="n">quads</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">faces</span><span class="p">[</span><span class="n">quads</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">quads</span> <span class="o">=</span> <span class="n">faces</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">faces</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">faces</span><span class="p">[</span><span class="n">quads</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">faces</span><span class="p">[</span><span class="n">quads</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">quads</span> <span class="o">=</span> <span class="n">faces</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">faces</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">faces</span><span class="p">[</span><span class="n">quads</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">faces</span><span class="p">[</span><span class="n">quads</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">quads</span> <span class="o">=</span> <span class="n">faces</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">faces</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">nquads_final</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">quads</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span> <span class="o">=</span> <span class="n">faces</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;* Ensuring consistent definition of triangles:&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nquads_final</span> <span class="o">&lt;</span> <span class="n">nquads_init</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">((</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">--&gt; </span><span class="si">%u</span><span class="s2"> triangles were described the wrong way and have been corrected&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">nquads_init</span> <span class="o">-</span> <span class="n">nquads_final</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">--&gt; Triangle description is consistent&quot;</span><span class="p">)</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="Mesh.remove_degenerated_faces"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.remove_degenerated_faces">[docs]</a>    <span class="k">def</span> <span class="nf">remove_degenerated_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes tiny triangles from the mesh.</span>

<span class="sd">        Tiny triangles are those whose area is lower than the mean triangle area in the mesh times the relative</span>
<span class="sd">        tolerance given.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rtol : float, optional</span>
<span class="sd">            Positive relative tolerance</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">rtol</span>

        <span class="c1"># TODO: implementer un retour d&#39;index des faces extraites</span>
        <span class="n">areas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces_areas</span>
        <span class="n">area_threshold</span> <span class="o">=</span> <span class="n">areas</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">rtol</span><span class="p">)</span>

        <span class="c1"># Detecting faces that have null area</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">areas</span> <span class="o">&lt;</span> <span class="n">area_threshold</span><span class="p">)]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span><span class="p">:</span>
            <span class="n">nb_removed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_faces</span> <span class="o">-</span> <span class="n">faces</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;* Removing degenerated faces&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nb_removed</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">((</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">--&gt;</span><span class="si">%u</span><span class="s1"> degenerated faces have been removed&#39;</span> <span class="o">%</span> <span class="n">nb_removed</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">--&gt; No degenerated faces&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span> <span class="o">=</span> <span class="n">faces</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_faces_properties</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_remove_faces_properties</span><span class="p">()</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="Mesh.heal_mesh"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.heal_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">heal_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Heals the mesh for different tests available.</span>

<span class="sd">        It applies:</span>

<span class="sd">        * Unused vertices removal</span>
<span class="sd">        * Degenerate faces removal</span>
<span class="sd">        * Duplicate vertices merging</span>
<span class="sd">        * Triangles healing</span>
<span class="sd">        * Normal healing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_faces_properties</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_remove_faces_properties</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_unused_vertices</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_degenerated_faces</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merge_duplicates</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">heal_triangles</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">heal_normals</span><span class="p">()</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="Mesh.triangulate_quadrangles"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.triangulate_quadrangles">[docs]</a>    <span class="k">def</span> <span class="nf">triangulate_quadrangles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Triangulates every quadrangles of the mesh by simple spliting.</span>

<span class="sd">        Each quadrangle gives two triangles.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        No checking is made on the triangle quality is done.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Ensure the best quality aspect ratio of generated triangles</span>

        <span class="c1"># Defining both triangles id lists to be generated from quadrangles</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="n">faces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span>

        <span class="c1"># Triangulation</span>
        <span class="n">new_faces</span> <span class="o">=</span> <span class="n">faces</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">quadrangles_ids</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_faces</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_faces</span><span class="p">[:,</span> <span class="n">t1</span><span class="p">]</span>
        <span class="n">new_faces</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_faces</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">faces</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">quadrangles_ids</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">faces</span><span class="p">[:,</span> <span class="n">t2</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">quadrangles_ids</span><span class="p">]</span>
        <span class="n">faces</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">quadrangles_ids</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">faces</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">quadrangles_ids</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">faces</span><span class="p">,</span> <span class="n">new_faces</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Triangulating quadrangles&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_quadrangles</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">((</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">--&gt;</span><span class="si">{:d}</span><span class="s1"> quadrangles have been split in triangles&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_quadrangles</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span> <span class="o">=</span> <span class="n">faces</span>

        <span class="k">return</span> <span class="n">faces</span></div>

<div class="viewcode-block" id="Mesh.symmetrize"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.symmetrize">[docs]</a>    <span class="k">def</span> <span class="nf">symmetrize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plane</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Symmetrize the mesh with respect to a plane.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        plane : Plane</span>
<span class="sd">            The plane of symmetry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Symmetrizing the nodes</span>
        <span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span>

        <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">vertices</span><span class="p">,</span> <span class="n">vertices</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">plane</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span> <span class="o">-</span> <span class="n">plane</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">plane</span><span class="o">.</span><span class="n">normal</span><span class="p">)))</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">faces</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">faces</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_vertices</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose_off</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merge_duplicates</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="k">return</span></div>

<div class="viewcode-block" id="Mesh.mirror"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.mirror">[docs]</a>    <span class="k">def</span> <span class="nf">mirror</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plane</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mirrors the mesh instance with respect to a plane.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        plane : Plane</span>
<span class="sd">            The mirroring plane</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span> <span class="o">-=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">,</span> <span class="n">plane</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span> <span class="o">-</span> <span class="n">plane</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">plane</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flip_normals</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">return</span></div>

    <span class="k">def</span> <span class="nf">_compute_faces_integrals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sum_faces_contrib</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span> <span class="c1"># TODO: implementer le sum_surface_contrib</span>

        <span class="c1"># TODO: Utiliser sum_faces_contrib</span>
        <span class="n">surface_integrals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">15</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_faces</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># First triangles</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_triangles</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">triangles_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">triangles_ids</span>
            <span class="c1"># print self._faces[triangles_ids][:, :3].shape</span>
            <span class="n">triangles_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="p">[</span><span class="n">triangles_ids</span><span class="p">][:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]]</span> <span class="c1"># Remettre le 3</span>
            <span class="n">surface_integrals</span><span class="p">[:,</span> <span class="n">triangles_ids</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_triangles_integrals</span><span class="p">(</span><span class="n">triangles_vertices</span><span class="p">)</span>

        <span class="c1"># Now quadrangles by splitting them up</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_quadrangles</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">quadrangles_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quadrangles_ids</span>
            <span class="n">quadrangles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="p">[</span><span class="n">quadrangles_ids</span><span class="p">]</span>

            <span class="c1"># First pass</span>
            <span class="n">surface_integrals</span><span class="p">[:,</span> <span class="n">quadrangles_ids</span><span class="p">]</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_compute_triangles_integrals</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[</span><span class="n">quadrangles</span><span class="p">[:,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]])</span>

            <span class="c1"># Second pass</span>
            <span class="n">surface_integrals</span><span class="p">[:,</span> <span class="n">quadrangles_ids</span><span class="p">]</span> <span class="o">+=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_compute_triangles_integrals</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[</span><span class="n">quadrangles</span><span class="p">[:,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;surface_integrals&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">surface_integrals</span>

        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_remove_surface_integrals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;surface_integrals&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;surface_integrals&#39;</span><span class="p">]</span>
        <span class="k">return</span>

<div class="viewcode-block" id="Mesh.has_surface_integrals"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.has_surface_integrals">[docs]</a>    <span class="k">def</span> <span class="nf">has_surface_integrals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;surface_integrals&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span></div>

<div class="viewcode-block" id="Mesh.get_surface_integrals"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.get_surface_integrals">[docs]</a>    <span class="k">def</span> <span class="nf">get_surface_integrals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the mesh surface integrals</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">            The mesh surface integrals array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: add an option to do the summation</span>
        <span class="c1"># TODO: decrire les integrales de surface en question</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_surface_integrals</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_faces_integrals</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;surface_integrals&#39;</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_compute_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_surface_integrals</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_faces_integrals</span><span class="p">()</span>

        <span class="n">normals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces_normals</span>
        <span class="n">sigma_0_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internals__</span><span class="p">[</span><span class="s1">&#39;surface_integrals&#39;</span><span class="p">][:</span><span class="mi">3</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">normals</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">sigma_0_2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="mf">3.</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the mesh enclosed volume</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The mesh volume</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_volume</span><span class="p">()</span>

    <span class="c1"># TODO: add the possibility to compute the inertia to an other point than [0, 0, 0]</span>
<div class="viewcode-block" id="Mesh.eval_plain_mesh_inertias"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.eval_plain_mesh_inertias">[docs]</a>    <span class="k">def</span> <span class="nf">eval_plain_mesh_inertias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rho_medium</span><span class="o">=</span><span class="mf">1023.</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluates the mesh inertia under the assumption of an enclosed volume made of an homogeneous medium of the given density.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rho_medium : float, optional</span>
<span class="sd">            The medium density (kg/m**3). Default is 1023 kg.m**3 (salt water)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        RigidBodyInertia</span>
<span class="sd">            The mesh inertia instance expressed at origin (0, 0, 0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: allow to specify an other point for inertia matrix expression</span>
        <span class="c1"># TODO: manipuler plutot un objet inertia --&gt; creer une classe !</span>
        <span class="n">rho_medium</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">rho_medium</span><span class="p">)</span>

        <span class="n">volume</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span>
        <span class="n">mass</span> <span class="o">=</span> <span class="n">rho_medium</span> <span class="o">*</span> <span class="n">volume</span>

        <span class="n">integrals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_surface_integrals</span><span class="p">()[</span><span class="mi">6</span><span class="p">:</span><span class="mi">15</span><span class="p">]</span>
        <span class="n">sigma_6_8</span> <span class="o">=</span> <span class="n">integrals</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>

        <span class="n">normals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces_normals</span><span class="o">.</span><span class="n">T</span>

        <span class="n">cog</span> <span class="o">=</span> <span class="p">(</span><span class="n">normals</span> <span class="o">*</span> <span class="n">sigma_6_8</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">volume</span><span class="p">)</span>

        <span class="n">sigma9</span><span class="p">,</span> <span class="n">sigma10</span><span class="p">,</span> <span class="n">sigma11</span> <span class="o">=</span> <span class="p">(</span><span class="n">normals</span> <span class="o">*</span> <span class="n">integrals</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">sigma12</span><span class="p">,</span> <span class="n">sigma13</span><span class="p">,</span> <span class="n">sigma14</span> <span class="o">=</span> <span class="p">(</span><span class="n">normals</span> <span class="o">*</span> <span class="n">integrals</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">10</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">xx</span> <span class="o">=</span> <span class="n">rho_medium</span> <span class="o">*</span> <span class="p">(</span><span class="n">sigma10</span> <span class="o">+</span> <span class="n">sigma11</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.</span>
        <span class="n">yy</span> <span class="o">=</span> <span class="n">rho_medium</span> <span class="o">*</span> <span class="p">(</span><span class="n">sigma9</span> <span class="o">+</span> <span class="n">sigma11</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.</span>
        <span class="n">zz</span> <span class="o">=</span> <span class="n">rho_medium</span> <span class="o">*</span> <span class="p">(</span><span class="n">sigma9</span> <span class="o">+</span> <span class="n">sigma10</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="n">rho_medium</span> <span class="o">*</span> <span class="n">sigma12</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="n">xz</span> <span class="o">=</span> <span class="n">rho_medium</span> <span class="o">*</span> <span class="n">sigma14</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="n">yz</span> <span class="o">=</span> <span class="n">rho_medium</span> <span class="o">*</span> <span class="n">sigma13</span> <span class="o">/</span> <span class="mf">2.</span>

        <span class="k">return</span> <span class="n">RigidBodyInertia</span><span class="p">(</span><span class="n">mass</span><span class="p">,</span> <span class="n">cog</span><span class="p">,</span> <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">zz</span><span class="p">,</span> <span class="n">yz</span><span class="p">,</span> <span class="n">xz</span><span class="p">,</span> <span class="n">xy</span><span class="p">,</span> <span class="n">point</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="Mesh.eval_shell_mesh_inertias"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.eval_shell_mesh_inertias">[docs]</a>    <span class="k">def</span> <span class="nf">eval_shell_mesh_inertias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rho_medium</span><span class="o">=</span><span class="mf">7850.</span><span class="p">,</span> <span class="n">thickness</span><span class="o">=</span><span class="mf">0.02</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluates the mesh inertia under the assumption of an enclosed volume made of an homogeneous medium of the</span>
<span class="sd">        given density.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rho_medium : float, optional</span>
<span class="sd">            The medium density (kg/m**3). Default is 7850 kg/m**3 (Steel density)</span>
<span class="sd">        thickness : flaot, optional</span>
<span class="sd">            The hull thickness (m). Default is 0.02 m.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        RigidBodyInertia</span>
<span class="sd">            The mesh inertia instance expressed at origin (0, 0, 0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rho_medium</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">rho_medium</span><span class="p">)</span>
        <span class="n">thickness</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">thickness</span><span class="p">)</span>
        <span class="n">surf_density</span> <span class="o">=</span> <span class="n">rho_medium</span> <span class="o">*</span> <span class="n">thickness</span>

        <span class="n">surface</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces_areas</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">mass</span> <span class="o">=</span> <span class="n">surf_density</span> <span class="o">*</span> <span class="n">surface</span>

        <span class="n">s0</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">s3</span><span class="p">,</span> <span class="n">s4</span><span class="p">,</span> <span class="n">s5</span><span class="p">,</span> <span class="n">s6</span><span class="p">,</span> <span class="n">s7</span><span class="p">,</span> <span class="n">s8</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_surface_integrals</span><span class="p">()[:</span><span class="mi">9</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">cog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">s0</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span> <span class="n">surface</span>

        <span class="n">xx</span> <span class="o">=</span> <span class="n">surf_density</span> <span class="o">*</span> <span class="p">(</span><span class="n">s7</span> <span class="o">+</span> <span class="n">s8</span><span class="p">)</span>
        <span class="n">yy</span> <span class="o">=</span> <span class="n">surf_density</span> <span class="o">*</span> <span class="p">(</span><span class="n">s6</span> <span class="o">+</span> <span class="n">s8</span><span class="p">)</span>
        <span class="n">zz</span> <span class="o">=</span> <span class="n">surf_density</span> <span class="o">*</span> <span class="p">(</span><span class="n">s6</span> <span class="o">+</span> <span class="n">s7</span><span class="p">)</span>
        <span class="n">yz</span> <span class="o">=</span> <span class="n">surf_density</span> <span class="o">*</span> <span class="n">s3</span>
        <span class="n">xz</span> <span class="o">=</span> <span class="n">surf_density</span> <span class="o">*</span> <span class="n">s4</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="n">surf_density</span> <span class="o">*</span> <span class="n">s5</span>

        <span class="k">return</span> <span class="n">RigidBodyInertia</span><span class="p">(</span><span class="n">mass</span><span class="p">,</span> <span class="n">cog</span><span class="p">,</span> <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">zz</span><span class="p">,</span> <span class="n">yz</span><span class="p">,</span> <span class="n">xz</span><span class="p">,</span> <span class="n">xy</span><span class="p">,</span> <span class="n">point</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span></div>

    <span class="k">def</span> <span class="nf">_edges_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes the min, max, and mean of the mesh&#39;s edge length&quot;&quot;&quot;</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">]</span>
        <span class="n">edge_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_faces</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">vertices</span><span class="p">[:,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">edge_length</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij, ij -&gt; i&#39;</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">edge</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">edge_length</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">edge_length</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">edge_length</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">min_edge_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The mesh&#39;s minimum edge length&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges_stats</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_edge_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The mesh&#39;s maximum edge length&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges_stats</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mean_edge_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The mesh&#39;s mean edge length&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges_stats</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_compute_triangles_integrals</span><span class="p">(</span><span class="n">triangles_vertices</span><span class="p">,</span> <span class="n">sum_faces_contrib</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Performs the computation of the various interesting surface integrals.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        triangles_vertices doit decrire par dimension croissante du general au particulier :</span>
<span class="sd">        dimension 0 : informations sur chaque facette -- triangles_vertices[0] -&gt; facette 0)</span>
<span class="sd">        dimension 1 : informations sur chaque vertex de la facette -- triangles_vertices[0, 1] -&gt; vertex 1 de la facette 0</span>
<span class="sd">        dimension 2 : information sur chacune des coordonnées des vertex -- triangles_vertices[0, 1, 2] -&gt; coordonnee z du vertex 1 de la facette 0</span>

<span class="sd">        Todo</span>
<span class="sd">        ----</span>
<span class="sd">        Explicit the integrals</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">s_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">15</span><span class="p">,</span> <span class="n">triangles_vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="n">point_0</span><span class="p">,</span> <span class="n">point_1</span><span class="p">,</span> <span class="n">point_2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_3DPointsArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">triangles_vertices</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>

        <span class="n">t0</span> <span class="o">=</span> <span class="n">point_0</span> <span class="o">+</span> <span class="n">point_1</span>
        <span class="n">f1</span> <span class="o">=</span> <span class="n">t0</span> <span class="o">+</span> <span class="n">point_2</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">point_0</span> <span class="o">*</span> <span class="n">point_0</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">t1</span> <span class="o">+</span> <span class="n">point_1</span><span class="o">*</span><span class="n">t0</span>
        <span class="n">f2</span> <span class="o">=</span> <span class="n">t2</span> <span class="o">+</span> <span class="n">point_2</span><span class="o">*</span><span class="n">f1</span>
        <span class="n">f3</span> <span class="o">=</span> <span class="n">point_0</span><span class="o">*</span><span class="n">t1</span> <span class="o">+</span> <span class="n">point_1</span><span class="o">*</span><span class="n">t2</span> <span class="o">+</span> <span class="n">point_2</span><span class="o">*</span><span class="n">f2</span>
        <span class="n">g0</span> <span class="o">=</span> <span class="n">f2</span> <span class="o">+</span> <span class="n">point_0</span> <span class="o">*</span> <span class="p">(</span><span class="n">f1</span> <span class="o">+</span> <span class="n">point_0</span><span class="p">)</span>
        <span class="n">g1</span> <span class="o">=</span> <span class="n">f2</span> <span class="o">+</span> <span class="n">point_1</span> <span class="o">*</span> <span class="p">(</span><span class="n">f1</span> <span class="o">+</span> <span class="n">point_1</span><span class="p">)</span>
        <span class="n">g2</span> <span class="o">=</span> <span class="n">f2</span> <span class="o">+</span> <span class="n">point_2</span> <span class="o">*</span> <span class="p">(</span><span class="n">f1</span> <span class="o">+</span> <span class="n">point_2</span><span class="p">)</span>

        <span class="n">e1</span> <span class="o">=</span> <span class="n">point_1</span> <span class="o">-</span> <span class="n">point_0</span>
        <span class="n">e2</span> <span class="o">=</span> <span class="n">point_2</span> <span class="o">-</span> <span class="n">point_0</span>

        <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">s_int</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i, ij -&gt; ji&#39;</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">f1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">6.</span>

        <span class="n">s_int</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">*</span> <span class="p">(</span><span class="mf">6.</span><span class="o">*</span><span class="n">point_0</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">point_0</span><span class="o">.</span><span class="n">z</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">point_1</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">point_1</span><span class="o">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">point_2</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">point_2</span><span class="o">.</span><span class="n">z</span><span class="p">)</span> <span class="o">-</span> <span class="n">point_0</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">f1</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">point_0</span><span class="o">.</span><span class="n">z</span><span class="o">*</span><span class="n">f1</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mf">12.</span>
        <span class="n">s_int</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">*</span> <span class="p">(</span><span class="mf">6.</span><span class="o">*</span><span class="n">point_0</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">point_0</span><span class="o">.</span><span class="n">z</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">point_1</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">point_1</span><span class="o">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">point_2</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">point_2</span><span class="o">.</span><span class="n">z</span><span class="p">)</span> <span class="o">-</span> <span class="n">point_0</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">f1</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">point_0</span><span class="o">.</span><span class="n">z</span><span class="o">*</span><span class="n">f1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mf">12.</span>
        <span class="n">s_int</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">*</span> <span class="p">(</span><span class="mf">6.</span><span class="o">*</span><span class="n">point_0</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">point_0</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">point_1</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">point_1</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">point_2</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">point_2</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">point_0</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">f1</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">point_0</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">f1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mf">12.</span>

        <span class="n">s_int</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i, ij -&gt; ji&#39;</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">f2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">12.</span>
        <span class="n">s_int</span><span class="p">[</span><span class="mi">9</span><span class="p">:</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i, ij -&gt; ji&#39;</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">f3</span><span class="p">)</span> <span class="o">/</span> <span class="mf">20.</span>

        <span class="n">s_int</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">*</span> <span class="p">(</span><span class="n">point_0</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">g0</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">point_1</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">g1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">point_2</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">g2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mf">60.</span>
        <span class="n">s_int</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">*</span> <span class="p">(</span><span class="n">point_0</span><span class="o">.</span><span class="n">z</span><span class="o">*</span><span class="n">g0</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">point_1</span><span class="o">.</span><span class="n">z</span><span class="o">*</span><span class="n">g1</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">point_2</span><span class="o">.</span><span class="n">z</span><span class="o">*</span><span class="n">g2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mf">60.</span>
        <span class="n">s_int</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">*</span> <span class="p">(</span><span class="n">point_0</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">g0</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">point_1</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">g1</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">point_2</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">g2</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="mf">60.</span>

        <span class="k">return</span> <span class="n">s_int</span>

<div class="viewcode-block" id="Mesh.quick_save"><a class="viewcode-back" href="../../api/meshmagick.mesh.html#meshmagick.mesh.Mesh.quick_save">[docs]</a>    <span class="k">def</span> <span class="nf">quick_save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Saves the current mesh instance in a VTK file.</span>

<span class="sd">        It is mainly for debugging purpose.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            If None, the file is automatically saved under the name quick_save.vtp.</span>
<span class="sd">            If the name given does not have a .vtp extension, the latter is appended automatically.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">filename</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;quick_save.vtp&#39;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.vtp&#39;</span><span class="p">):</span>
            <span class="n">filename</span> <span class="o">+=</span> <span class="s1">&#39;.vtp&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">.mmio</span> <span class="kn">import</span> <span class="n">write_VTP</span>
            <span class="n">write_VTP</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">((</span><span class="s1">&#39;File </span><span class="si">%s</span><span class="s1"> written&#39;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s1">&#39;mmio module not found&#39;</span><span class="p">)</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2021, Ecole Centrale de Nantes
      <span class="lastupdated">
        Last updated on Oct 19, 2021.
      </span>

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>